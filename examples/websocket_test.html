<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unsaycret WebSocket æ¸¬è©¦</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
            border-bottom: 3px solid #007bff;
            padding-bottom: 10px;
        }
        .section {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: #fafafa;
        }
        .section h3 {
            margin-top: 0;
            color: #007bff;
        }
        .form-group {
            margin: 15px 0;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }
        input, select, textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            box-sizing: border-box;
        }
        button {
            background: #007bff;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px;
        }
        button:hover {
            background: #0056b3;
        }
        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        .success {
            background: #28a745;
        }
        .danger {
            background: #dc3545;
        }
        .warning {
            background: #ffc107;
            color: #333;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-weight: bold;
        }
        .status.connected {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.disconnected {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .status.connecting {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        #log {
            height: 300px;
            overflow-y: auto;
            background: #f8f9fa;
            padding: 15px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            white-space: pre-wrap;
        }
        .responses {
            max-height: 400px;
            overflow-y: auto;
            background: #f8f9fa;
            padding: 15px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
        }
        .response-item {
            background: white;
            padding: 10px;
            margin: 10px 0;
            border-left: 4px solid #007bff;
            border-radius: 4px;
        }
        .speaker-item {
            background: #e9ecef;
            padding: 8px;
            margin: 5px 0;
            border-radius: 4px;
        }
        .file-drop {
            border: 2px dashed #007bff;
            padding: 40px;
            text-align: center;
            border-radius: 8px;
            background: #f8f9fa;
            cursor: pointer;
            transition: all 0.3s;
        }
        .file-drop:hover {
            background: #e9ecef;
        }
        .file-drop.dragover {
            background: #cce5ff;
            border-color: #0056b3;
        }
        .recording {
            background: #dc3545 !important;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ™ï¸ Unsaycret WebSocket æ¸¬è©¦å·¥å…·</h1>
        
        <!-- é€£ç·šè¨­å®š -->
        <div class="section">
            <h3>ğŸ“¡ é€£ç·šè¨­å®š</h3>
            <div class="form-group">
                <label for="wsUrl">WebSocket URL:</label>
                <input type="text" id="wsUrl" value="ws://localhost:8000/ws/stream">
            </div>
            <div class="form-group">
                <label for="sessionUuid">Session UUID:</label>
                <input type="text" id="sessionUuid" placeholder="è«‹è¼¸å…¥æœ‰æ•ˆçš„ Session UUID">
                <button onclick="createTestSession()">å»ºç«‹æ¸¬è©¦ Session</button>
            </div>
            <div id="connectionStatus" class="status disconnected">ğŸ”´ æœªé€£ç·š</div>
            <button id="connectBtn" onclick="toggleConnection()">ğŸ”— é€£ç·š</button>
            <button onclick="clearLog()">ğŸ§¹ æ¸…é™¤æ—¥èªŒ</button>
        </div>
        
        <!-- éŸ³è¨Šæ¸¬è©¦ -->
        <div class="section">
            <h3>ğŸµ å³æ™‚éŒ„éŸ³æ¸¬è©¦</h3>
            
            <!-- éº¥å…‹é¢¨éŒ„éŸ³ -->
            <div class="form-group">
                <button id="recordBtn" onclick="toggleRecording()">ğŸ¤ é–‹å§‹éŒ„éŸ³</button>
                <span id="recordStatus"></span>
            </div>
            
            <button onclick="sendStopSignal()" id="stopBtn" disabled>ğŸ›‘ åœæ­¢éŒ„éŸ³</button>
            <button onclick="checkSessionStatus()" id="checkBtn">ğŸ“Š æª¢æŸ¥ Session ç‹€æ…‹</button>
        </div>
        
        <!-- æ—¥èªŒ -->
        <div class="section">
            <h3>ğŸ“„ é€£ç·šæ—¥èªŒ</h3>
            <div id="log"></div>
        </div>
        
        <!-- å›æ‡‰çµæœ -->
        <div class="section">
            <h3>ğŸ“¥ WebSocket å›æ‡‰</h3>
            <div id="responses" class="responses"></div>
        </div>
    </div>

    <script>
        let ws = null;
        let isConnected = false;
        let audioContext = null;
        let processor = null;
        let isRecording = false;
        let audioStream = null;
        let audioDataSent = 0;  // è¿½è¹¤å·²ç™¼é€çš„éŸ³è¨Šè³‡æ–™é‡

        // æ›´æ–°é€£ç·šç‹€æ…‹
        function updateConnectionStatus(status, message) {
            const statusEl = document.getElementById('connectionStatus');
            const connectBtn = document.getElementById('connectBtn');
            const recordBtn = document.getElementById('recordBtn');
            const stopBtn = document.getElementById('stopBtn');
            
            statusEl.className = `status ${status}`;
            
            switch(status) {
                case 'connected':
                    statusEl.textContent = `ğŸŸ¢ å·²é€£ç·š - ${message}`;
                    connectBtn.textContent = 'ğŸ”Œ æ–·ç·š';
                    recordBtn.disabled = false;
                    stopBtn.disabled = false;
                    break;
                case 'connecting':
                    statusEl.textContent = `ğŸŸ¡ é€£ç·šä¸­... - ${message}`;
                    connectBtn.disabled = true;
                    recordBtn.disabled = true;
                    stopBtn.disabled = true;
                    break;
                case 'disconnected':
                default:
                    statusEl.textContent = `ğŸ”´ æœªé€£ç·š - ${message}`;
                    connectBtn.textContent = 'ğŸ”— é€£ç·š';
                    connectBtn.disabled = false;
                    recordBtn.disabled = true;
                    stopBtn.disabled = true;
                    break;
            }
        }

        // æ—¥èªŒè¨˜éŒ„
        function log(message, type = 'info') {
            const logEl = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            const prefix = type === 'error' ? 'âŒ' : type === 'success' ? 'âœ…' : type === 'warning' ? 'âš ï¸' : 'â„¹ï¸';
            logEl.textContent += `[${timestamp}] ${prefix} ${message}\n`;
            logEl.scrollTop = logEl.scrollHeight;
        }

        // æ¸…é™¤æ—¥èªŒ
        function clearLog() {
            document.getElementById('log').textContent = '';
            document.getElementById('responses').innerHTML = '';
        }

        // å»ºç«‹æ¸¬è©¦ Session
        async function createTestSession() {
            try {
                const response = await fetch('http://localhost:8000/sessions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        session_type: 'test',
                        title: 'ç€è¦½å™¨ WebSocket æ¸¬è©¦',
                        summary: 'ä½¿ç”¨ç€è¦½å™¨ä»‹é¢æ¸¬è©¦ WebSocket åŠŸèƒ½'
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    const uuid = result.data.uuid;
                    document.getElementById('sessionUuid').value = uuid;
                    log(`æˆåŠŸå»ºç«‹æ¸¬è©¦ Session: ${uuid}`, 'success');
                } else {
                    log(`å»ºç«‹ Session å¤±æ•—: ${result.message}`, 'error');
                }
            } catch (error) {
                log(`å»ºç«‹ Session éŒ¯èª¤: ${error.message}`, 'error');
            }
        }

        // åˆ‡æ›é€£ç·š
        function toggleConnection() {
            if (isConnected) {
                disconnect();
            } else {
                connect();
            }
        }

        // é€£ç·šåˆ° WebSocket
        function connect() {
            const wsUrl = document.getElementById('wsUrl').value;
            const sessionUuid = document.getElementById('sessionUuid').value;
            
            if (!sessionUuid) {
                log('è«‹å…ˆè¼¸å…¥ Session UUID', 'error');
                return;
            }
            
            const fullUrl = `${wsUrl}?session=${sessionUuid}`;
            updateConnectionStatus('connecting', 'å»ºç«‹é€£ç·šä¸­...');
            log(`å˜—è©¦é€£ç·šåˆ°: ${fullUrl}`);
            
            try {
                ws = new WebSocket(fullUrl);
                
                ws.onopen = function() {
                    isConnected = true;
                    updateConnectionStatus('connected', sessionUuid.substring(0, 8) + '...');
                    log('WebSocket é€£ç·šæˆåŠŸ', 'success');
                };
                
                ws.onmessage = function(event) {
                    try {
                        const data = JSON.parse(event.data);
                        log(`æ”¶åˆ°å›æ‡‰: Segment ${data.segment || 'N/A'}`);
                        displayResponse(data);
                    } catch (error) {
                        log(`è§£æå›æ‡‰éŒ¯èª¤: ${error.message}`, 'error');
                        log(`åŸå§‹è³‡æ–™: ${event.data}`);
                    }
                };
                
                ws.onclose = function(event) {
                    isConnected = false;
                    if (event.code === 1008) {
                        updateConnectionStatus('disconnected', 'Session UUID ç„¡æ•ˆ');
                        log('é€£ç·šè¢«æ‹’çµ•: Session UUID ç„¡æ•ˆ', 'error');
                    } else {
                        updateConnectionStatus('disconnected', `é—œé–‰ä»£ç¢¼: ${event.code}`);
                        log(`WebSocket é€£ç·šé—œé–‰: ${event.code} - ${event.reason}`, 'warning');
                    }
                    
                    // é€£ç·šé—œé–‰å¾Œè‡ªå‹•æª¢æŸ¥ Session ç‹€æ…‹
                    setTimeout(() => {
                        log('é€£ç·šå·²é—œé–‰ï¼Œæª¢æŸ¥ Session ç‹€æ…‹...', 'info');
                        checkSessionStatus();
                    }, 2000);
                };
                
                ws.onerror = function(error) {
                    log(`WebSocket éŒ¯èª¤: ${error}`, 'error');
                    updateConnectionStatus('disconnected', 'é€£ç·šéŒ¯èª¤');
                };
                
            } catch (error) {
                log(`å»ºç«‹é€£ç·šå¤±æ•—: ${error.message}`, 'error');
                updateConnectionStatus('disconnected', 'é€£ç·šå¤±æ•—');
            }
        }

        // æ–·ç·š
        function disconnect() {
            // åœæ­¢éŒ„éŸ³
            if (isRecording) {
                stopRecording();
            }
            
            if (ws) {
                ws.close();
                ws = null;
            }
            isConnected = false;
            updateConnectionStatus('disconnected', 'æ‰‹å‹•æ–·ç·š');
            log('å·²æ–·ç·š', 'warning');
        }

        // é¡¯ç¤ºå›æ‡‰
        function displayResponse(data) {
            const responsesEl = document.getElementById('responses');
            const responseDiv = document.createElement('div');
            responseDiv.className = 'response-item';
            
            let html = `
                <strong>Segment ${data.segment || 'N/A'}</strong>
                <br>æ™‚é–“: ${data.start || 'N/A'}s - ${data.end || 'N/A'}s
                <br>èªè€…æ•¸é‡: ${(data.speakers || []).length}
            `;
            
            if (data.speakers && data.speakers.length > 0) {
                html += '<br><br><strong>èªè€…è©³æƒ…:</strong>';
                data.speakers.forEach((speaker, index) => {
                    html += `
                        <div class="speaker-item">
                            <strong>èªè€… ${index + 1}:</strong> ${speaker.speaker_id || 'N/A'}<br>
                            <strong>æ–‡å­—:</strong> "${speaker.text || 'N/A'}"<br>
                            <strong>ä¿¡å¿ƒå€¼:</strong> ${(speaker.confidence * 100).toFixed(1)}%<br>
                            ${speaker.absolute_start_time ? `<strong>çµ•å°æ™‚é–“:</strong> ${speaker.absolute_start_time}<br>` : ''}
                        </div>
                    `;
                });
            }
            
            responseDiv.innerHTML = html;
            responsesEl.insertBefore(responseDiv, responsesEl.firstChild);
            
            // é™åˆ¶é¡¯ç¤ºæ•¸é‡
            while (responsesEl.children.length > 10) {
                responsesEl.removeChild(responsesEl.lastChild);
            }
        }

        // å³æ™‚éŒ„éŸ³åŠŸèƒ½
        async function toggleRecording() {
            if (!isConnected) {
                log('è«‹å…ˆé€£ç·šåˆ° WebSocket', 'error');
                return;
            }

            if (isRecording) {
                stopRecording();
            } else {
                await startRecording();
            }
        }

        async function startRecording() {
            try {
                // è«‹æ±‚éº¥å…‹é¢¨æ¬Šé™
                audioStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        sampleRate: 16000,
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: true
                    }
                });

                log('å·²ç²å¾—éº¥å…‹é¢¨æ¬Šé™ï¼Œè¨­å®šéŸ³è¨Šè™•ç†...', 'success');

                // å‰µå»º AudioContext è™•ç†éŸ³è¨Š
                audioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: 16000
                });

                const source = audioContext.createMediaStreamSource(audioStream);
                
                // å‰µå»º ScriptProcessor æˆ– AudioWorklet è™•ç†éŸ³è¨Š
                if (audioContext.createScriptProcessor) {
                    // ä½¿ç”¨ ScriptProcessor (è¼ƒèˆŠä½†ç›¸å®¹æ€§å¥½)
                    processor = audioContext.createScriptProcessor(4096, 1, 1);
                    
                    processor.onaudioprocess = function(event) {
                        if (!isRecording || !isConnected || !ws) return;
                        
                        const inputData = event.inputBuffer.getChannelData(0);
                        
                        // ç°¡å–®éŸ³é‡æª¢æ¸¬
                        let sum = 0;
                        for (let i = 0; i < inputData.length; i++) {
                            sum += Math.abs(inputData[i]);
                        }
                        const avgVolume = sum / inputData.length;
                        
                        // è½‰æ›ç‚º 16-bit PCM
                        const pcmData = new Int16Array(inputData.length);
                        for (let i = 0; i < inputData.length; i++) {
                            // å°‡ float32 (-1 to 1) è½‰æ›ç‚º int16 (-32768 to 32767)
                            pcmData[i] = Math.max(-32768, Math.min(32767, inputData[i] * 32768));
                        }
                        
                        // ç™¼é€ PCM è³‡æ–™
                        ws.send(pcmData.buffer);
                        audioDataSent += pcmData.buffer.byteLength;
                        
                        // æ¯10æ¬¡åªé¡¯ç¤ºä¸€æ¬¡æ—¥èªŒï¼Œä¸¦é¡¯ç¤ºéŸ³é‡
                        if (audioDataSent % (8192 * 10) === 0) {
                            log(`éŸ³è¨Šè³‡æ–™: ${(audioDataSent / 1024).toFixed(0)}KBï¼ŒéŸ³é‡: ${(avgVolume * 100).toFixed(1)}%`);
                        }
                    };
                    
                    source.connect(processor);
                    processor.connect(audioContext.destination);
                }

                isRecording = true;

                // æ›´æ–°UI
                const recordBtn = document.getElementById('recordBtn');
                const recordStatus = document.getElementById('recordStatus');
                recordBtn.textContent = 'ğŸ›‘ åœæ­¢éŒ„éŸ³';
                recordBtn.classList.add('recording');
                recordStatus.textContent = 'ğŸ”´ éŒ„éŸ³ä¸­...';

                log('é–‹å§‹å³æ™‚éŒ„éŸ³ (PCM 16kHz)', 'success');

            } catch (error) {
                log(`ç„¡æ³•å•Ÿå‹•éŒ„éŸ³: ${error.message}`, 'error');
                if (error.name === 'NotAllowedError') {
                    log('è«‹å…è¨±ç€è¦½å™¨å­˜å–éº¥å…‹é¢¨', 'error');
                } else if (error.name === 'NotFoundError') {
                    log('æ‰¾ä¸åˆ°éº¥å…‹é¢¨è¨­å‚™', 'error');
                }
            }
        }

        function stopRecording() {
            if (isRecording) {
                isRecording = false;
                log(`åœæ­¢éŒ„éŸ³ï¼Œç¸½å…±ç™¼é€ ${(audioDataSent / 1024).toFixed(0)}KB éŸ³è¨Šè³‡æ–™`, 'warning');
                audioDataSent = 0;  // é‡ç½®è¨ˆæ•¸
            }

            if (processor) {
                processor.disconnect();
                processor = null;
            }

            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }

            if (audioStream) {
                audioStream.getTracks().forEach(track => track.stop());
                audioStream = null;
            }

            // æ›´æ–°UI
            const recordBtn = document.getElementById('recordBtn');
            const recordStatus = document.getElementById('recordStatus');
            recordBtn.textContent = 'ğŸ¤ é–‹å§‹éŒ„éŸ³';
            recordBtn.classList.remove('recording');
            recordStatus.textContent = '';
        }

        // ç™¼é€åœæ­¢ä¿¡è™Ÿ
        function sendStopSignal() {
            stopRecording();
            
            if (isConnected && ws) {
                ws.send('stop');
                log('ç™¼é€åœæ­¢ä¿¡è™Ÿ', 'warning');
            }
        }

        // æª¢æŸ¥ Session ç‹€æ…‹
        async function checkSessionStatus() {
            const sessionUuid = document.getElementById('sessionUuid').value;
            if (!sessionUuid) {
                log('è«‹å…ˆè¼¸å…¥ Session UUID', 'error');
                return;
            }

            try {
                // æª¢æŸ¥ Session è³‡è¨Š
                const sessionResponse = await fetch(`http://localhost:8000/sessions/${sessionUuid}`);
                const sessionData = await sessionResponse.json();
                
                log('=== Session ç‹€æ…‹æª¢æŸ¥ ===', 'info');
                log(`Session ID: ${sessionData.session_id || 'N/A'}`, 'info');
                log(`æ¨™é¡Œ: ${sessionData.title || 'N/A'}`, 'info');
                log(`é–‹å§‹æ™‚é–“: ${sessionData.start_time || 'N/A'}`, 'info');
                log(`çµæŸæ™‚é–“: ${sessionData.end_time || 'N/A'}`, 'info');
                log(`åƒèˆ‡è€…æ•¸é‡: ${(sessionData.participants || []).length}`, 'info');

                // æª¢æŸ¥ SpeechLog
                const speechlogResponse = await fetch(`http://localhost:8000/sessions/${sessionUuid}/speechlogs`);
                const speechlogData = await speechlogResponse.json();
                
                log(`SpeechLog æ•¸é‡: ${speechlogData.length || 0}`, 'info');
                
                if (speechlogData.length > 0) {
                    speechlogData.forEach((log, index) => {
                        log(`  ${index + 1}. [${log.timestamp || 'N/A'}] ${log.content || 'N/A'} (${log.duration || 'N/A'}s)`, 'info');
                    });
                }
                
                log('=== æª¢æŸ¥å®Œæˆ ===', 'success');
                
            } catch (error) {
                log(`æª¢æŸ¥ Session ç‹€æ…‹å¤±æ•—: ${error.message}`, 'error');
            }
        }

        // åˆå§‹åŒ–
        updateConnectionStatus('disconnected', 'ç­‰å¾…é€£ç·š');
        log('WebSocket å³æ™‚éŒ„éŸ³æ¸¬è©¦å·¥å…·å·²æº–å‚™å°±ç·’');
        log('æ³¨æ„: éœ€è¦ HTTPS æˆ– localhost æ‰èƒ½ä½¿ç”¨éº¥å…‹é¢¨åŠŸèƒ½', 'warning');
    </script>
</body>
</html>
